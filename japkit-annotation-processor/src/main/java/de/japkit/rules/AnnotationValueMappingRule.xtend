package de.japkit.rules

import de.japkit.metaannotations.AVMode
import de.japkit.model.GenAnnotationMirror
import de.japkit.model.GenAnnotationValue
import de.japkit.services.ProcessingException
import java.util.ArrayList
import java.util.List
import java.util.Map
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.Element
import javax.lang.model.type.TypeMirror
import org.eclipse.xtend.lib.annotations.Data

@Data
class AnnotationValueMappingRule extends AbstractRule{

	()=>boolean activationRule
	String name
	String value
	String expr
	String lang
	String annotationMappingId
	AVMode mode


	def GenAnnotationValue mapAnnotationValue(GenAnnotationMirror annotation, TypeMirror avType, Map<String, AnnotationMappingRule> mappingsWithId) {
		inRule[
			//existing value (without considering defaults!)
			val existingValue = annotation?.getValueWithoutDefault(name)
			
			if(!activationRule.apply){
				return existingValue
			}
	
			if (existingValue != null) {
				switch (mode) {
					case AVMode.ERROR_IF_EXISTS:
						throw new ProcessingException(
							'''The annotation value «name» was already generated by another rule and the mapping mode is «mode».''', if(currentSrc instanceof Element) currentSrcElement)
					case AVMode.IGNORE:
						return existingValue
					case AVMode.REMOVE:
						return null
					case AVMode.REPLACE: { /**Nothing to do but continue. */
					}
					case AVMode.JOIN_LIST: { /**Nothing to do but here. TODO: After calculating the new value, apply the "join" */
					}
					case AVMode.MERGE:{
						
					}
				}
			}
	
			val v = 
				if (!value.nullOrEmpty) {
					coerceAnnotationValue(value, avType)
				} else if (!annotationMappingId.nullOrEmpty){
					val annotationMapping = mappingsWithId?.get(annotationMappingId)
					if(annotationMapping==null){
						throw new IllegalArgumentException('''Annotation rule with id «annotationMappingId» not found.''')
					}
					if(expr.nullOrEmpty){
						
							val annotations = newArrayList 
							annotationMapping.mapOrCopyAnnotations(annotations, mappingsWithId)
							if(!annotations.empty){
								coerceAnnotationValue(annotations.head, avType)
							} else {
								null 
							}
						
					} else {
						val elements = eval(expr, lang, Iterable) as Iterable<Element>  //TODO: Check if instanceof element
						val annotations = newArrayList 
						elements.forEach[
							scope(it)[
								annotationMapping.mapOrCopyAnnotations(annotations, mappingsWithId)
								null
							]
						]
						coerceAnnotationValue(annotations, avType)
					}
					
				} else if (!expr.nullOrEmpty) {
					evaluateExpression(avType, expr)
				} else {
	
					//messager.printMessage(Kind.ERROR, '''Either 'value' or 'expr' must be set.''', am)
					throw new IllegalArgumentException(
						"Error in annotation value mapping: Either 'value' or 'expr' or 'annotationMappingId'must be set.")
				}
	
			if(v==null){
				return existingValue;  //No value... Leave existing value unchanged.
			}
			
			if (mode == AVMode.JOIN_LIST && existingValue != null) {
				val joined = new ArrayList(existingValue.valueWithErrorHandling as List<Object>)
				joined.addAll(v as List<Object>)
				new GenAnnotationValue(joined)
			} else {
				new GenAnnotationValue(v)
			}
		
		]

	}

	def private Object evaluateExpression(TypeMirror avType, String expr) {

		val targetClass = if(avType.kind.isPrimitive) avType.toAnnotationValueClass else Object

		val result = eval(expr, lang, targetClass)

		coerceAnnotationValue(result, avType)

	}


	new(AnnotationMirror a) {
		super(a, null)
		name = a.value(null, "name", String)
		value = a.value(null, "value", String)
		expr = a.value(null, "expr", String)
		lang = a.value(null, "lang", String)
		mode = a.value(null, "mode", AVMode)
		annotationMappingId = a.value(null, "annotationMappingId", String)
		activationRule = createActivationRule(a, null)

	}
}
