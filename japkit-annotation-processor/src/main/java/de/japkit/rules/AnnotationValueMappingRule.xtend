package de.japkit.rules

import de.japkit.metaannotations.AVMode
import de.japkit.model.GenAnnotationMirror
import de.japkit.model.GenAnnotationValue
import de.japkit.services.RuleException
import java.util.ArrayList
import java.util.List
import java.util.Map
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.Element
import javax.lang.model.type.TypeMirror
import org.eclipse.xtend.lib.annotations.Data

import static extension de.japkit.rules.RuleUtils.withPrefix

@Data
class AnnotationValueMappingRule extends AbstractRule {

	()=>boolean activationRule
	String name
	Object value
	String expr
	String exprAvName
	String lang
	()=>AnnotationMappingRule lazyAnnotationMapping
	AVMode mode
	((Object)=>Object)=>Iterable<Object> scopeRule

	def GenAnnotationValue mapAnnotationValue(GenAnnotationMirror annotation, TypeMirror avType) {
		inRule[
			//existing value (without considering defaults!)
			val existingValue = annotation?.getValueWithoutDefault(name)
			
			if(!activationRule.apply){
				return existingValue
			}
	
			if (existingValue != null) {
				switch (mode) {
					case AVMode.ERROR_IF_EXISTS:
						throw new RuleException(
							'''The annotation value «name» was already generated by another rule and the mapping mode is «mode».''')
					case AVMode.IGNORE:
						return existingValue
					case AVMode.REMOVE:
						return null
					case AVMode.REPLACE: { /**Nothing to do but continue. */
					}
					case AVMode.JOIN_LIST: { /**Nothing to do but here. TODO: After calculating the new value, apply the "join" */
					}
					case AVMode.MERGE:{
						
					}
				}
			}
	
			val flatValues = newArrayList
			
			scopeRule.apply [
				if (value != null) {
					value
				} else if (lazyAnnotationMapping != null) {

					val annotationMapping = lazyAnnotationMapping.apply

					val annotations = newArrayList
					annotationMapping.mapOrCopyAnnotations(annotations)
					annotations as ArrayList<? extends Object>

				} else if(expr != null) {
					evaluateExpression(avType, expr)
				} else {
					//This AV shall not be set. Is relevant for annotation templates. There AVMRs are created for each AV.
					//Could be optimized by dropping the ones that are "empty", since neither expr nor value nor annotationMapping is set.
					null
				}
			]?.forEach[if(it instanceof Iterable<?>) flatValues.addAll(it) else flatValues.add(it)]
			
			val v = coerceAnnotationValue(flatValues, avType)
	
			if(v==null){
				return existingValue;  //No value... Leave existing value unchanged.
			}
			
			if (mode == AVMode.JOIN_LIST && existingValue != null) {
				val joined = new ArrayList(existingValue.valueWithErrorHandling as List<Object>)
				joined.addAll(v as List<Object>)
				new GenAnnotationValue(joined)
			} else {
				new GenAnnotationValue(v)
			}
		
		]

	}

	def private Object evaluateExpression(TypeMirror avType, String expr) {

		val targetClass = if(avType.kind.isPrimitive) avType.toAnnotationValueClass else Object

		handleException(null, exprAvName)[ 
			eval(expr, lang, targetClass)
			
		]

	}


	new(AnnotationMirror a,  Map<String, AnnotationMappingRule> mappingsWithId) {
		super(a, null)
		name = a.value(null, "name", String)
		value = a.value(null, "value", String)
		exprAvName="expr"
		expr = a.value(null, exprAvName, String)
		lang = a.value(null, "lang", String)
		mode = a.value(null, "mode", AVMode)
		val annotationMappingId = a.value(null, "annotationMappingId", String)
		lazyAnnotationMapping = if(annotationMappingId.nullOrEmpty) null else [| 
			val amr = mappingsWithId.get(annotationMappingId)
			if(amr==null){
				throw new IllegalArgumentException("Annotation Mapping with id "+annotationMappingId+" not found");
			}
			amr
		]
		//Could be optimized by dropping the ones that are "empty", since neither expr nor value nor annotationMapping is set.
		if(#[expr!=null,value!=null,lazyAnnotationMapping!=null].filter[it].size != 1){
			throwRuleCreationException('''Exactly one of the annotation values 'value', '«exprAvName»', 'annotationMappingId' must be set.''')
		}
		activationRule = createActivationRule(a, null)
		scopeRule = createScopeRule(a, null, null)

	}
	
	new(AnnotationMirror a,  Element templateElement, String avName) {
		super(a, templateElement)
		name = avName
		value = a.value(avName, Object)
		
		val avPrefix = avName+'_'
		exprAvName="expr".withPrefix(avPrefix)
		expr = a.value(exprAvName, String)
		lang = a.value("lang".withPrefix(avPrefix), String)
		mode = AVMode.JOIN_LIST
		
		
		val annotationMappingAnnotation =  a.value(avPrefix, AnnotationMirror)
		
		lazyAnnotationMapping = if (annotationMappingAnnotation == null) null else {
			val amr = new AnnotationMappingRule(annotationMappingAnnotation, templateElement);
			[| amr]
		}
		
		if(#[expr!=null,value!=null,lazyAnnotationMapping!=null].filter[it].size > 1){
			throwRuleCreationException('''At most one of the annotation values '«avName»', '«exprAvName»', '«avPrefix»' must be set.''')
		}
		
		activationRule = createActivationRule(a, avPrefix)
		scopeRule = createScopeRule(a, null, avPrefix)

	}
}
