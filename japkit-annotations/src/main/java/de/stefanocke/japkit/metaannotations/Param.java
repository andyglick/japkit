package de.stefanocke.japkit.metaannotations;

import javax.lang.model.element.Element;

import de.stefanocke.japkit.metaannotations.classselectors.None;

public @interface Param {
	//TODO: Do we really want to allow overriding for such an "inner" annotation as @Param ?
	String _prefix() default "<methodParam>";
	
	
	/**
	 * By default, only one param is generated by that annotation. To generate
	 * multiple similar params you can set an EL expression here. It must be an
	 * {@link Iterable} over {@link Element}. For each of those elements, a
	 * param is generated. The element is also used as rule source element for
	 * all matchers and EL expressions in the following. (For example, this
	 * allows for a nameExpr that determines the name depending on that
	 * element.)
	 * 
	 * @return
	 */
	String iterator() default "";

	/**
	 * 
	 * @return the language of the iterator expression. Defaults to Java EL.
	 */
	String iteratorLang() default "";
	
	/**
	 * How to map annotations of the source element (???) to the method parameter
	 * <p>
	 * 
	 * @return the annotation mappings
	 */
	AnnotationMapping[] annotationMappings() default {};
	
	/** name of the parameter*/
	String name() default "";
	
	/**
	 * For more complex cases: a Java EL expression to generate the name of the
	 * parameter. 
	 * 
	 * @return
	 */
	String nameExpr() default "";

	/**
	 * 
	 * @return the language of the name expression. Defaults to Java EL.
	 */
	String nameLang() default "";
	
	
	Class<?> type() default None.class;
	
	Class<?>[] typeArgs() default {};
		
}
